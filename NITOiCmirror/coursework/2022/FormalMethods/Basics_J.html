<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="Basics_J_files/coqdoc.css" rel="stylesheet" type="text/css">
<title>ソフトウェアの基礎</title>
  <!-- Google Analytics -->
  <script type="text/javascript" async="" src="Basics_J_files/ga.js"></script><script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6143321-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>
  <!-- Google Analytics -->
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">
<h1 class="libtitle">Basics_J: 関数プログラミングとプログラムの証明</h1>

<div class="code">
</div>

<div class="doc">

</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab12"></a><h1 class="section">列挙型</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
プログラミング言語Coqには、ほとんど何も（ブール型や数値型すら）ビルトインされていません。その代わりCoqには、新しい型やそれを処理するための強力なツールが用意されています。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab13"></a><h2 class="section">曜日の表し方</h2>

</div>
<div class="code">

<br>
</div>

<div class="doc">
まず最初はとても簡単なサンプルから始めましょう。次の定義は、Coqに対して、新しいデータ型のセット（集合）である'型'を定義しています。その型は<span class="inlinecode"><span class="id" type="var">day</span></span>で、要素は<span class="inlinecode"><span class="id" type="var">monday</span></span>、<span class="inlinecode"><span class="id" type="var">tuesday</span></span>...などです。その定義の1行は以下のようにも読めます。"<span class="inlinecode"><span class="id" type="var">monday</span></span>は<span class="inlinecode"><span class="id" type="var">day</span></span>。<span class="inlinecode"><span class="id" type="var">tuesday</span></span>は<span class="inlinecode"><span class="id" type="var">day</span></span>"といった具合です。
 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Inductive</span> <a name="day"><span class="id" type="inductive">day</span></a> : <span class="id" type="keyword">Type</span> :=<br>
&nbsp;&nbsp;| <a name="monday"><span class="id" type="constructor">monday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="tuesday"><span class="id" type="constructor">tuesday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="wednesday"><span class="id" type="constructor">wednesday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="thursday"><span class="id" type="constructor">thursday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="friday"><span class="id" type="constructor">friday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="saturday"><span class="id" type="constructor">saturday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a><br>
&nbsp;&nbsp;| <a name="sunday"><span class="id" type="constructor">sunday</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a>.<br>

<br>
</div>

<!-- ■ -->
<!-- day型のデータはmonday～sunday -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
day型のデータはmonday～sunday
</span><br><br>

<div class="doc">
"<span class="inlinecode"><span class="id" type="var">day</span></span>"が何かを定義できれば、それを利用して関数を書くこともできるでしょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="next_weekday"><span class="id" type="definition">next_weekday</span></a> (<span class="id" type="var">d</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#day"><span class="id" type="inductive">day</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#monday"><span class="id" type="constructor">monday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#tuesday"><span class="id" type="constructor">tuesday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#tuesday"><span class="id" type="constructor">tuesday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#wednesday"><span class="id" type="constructor">wednesday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#wednesday"><span class="id" type="constructor">wednesday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#thursday"><span class="id" type="constructor">thursday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#thursday"><span class="id" type="constructor">thursday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#friday"><span class="id" type="constructor">friday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#friday"><span class="id" type="constructor">friday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#monday"><span class="id" type="constructor">monday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#saturday"><span class="id" type="constructor">saturday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#monday"><span class="id" type="constructor">monday</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#sunday"><span class="id" type="constructor">sunday</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#monday"><span class="id" type="constructor">monday</span></a><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- 次の曜日を返す関数 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
次の平日を返す関数
</span><br><br>

<div class="doc">
一つ注意しておかなければならないことがあります。この関数の定義では、引数の型と戻り値の型が明示されていることです。他の多くの関数型プログラミング
言語と同様、Coqはこのように型を明示的に書かずともちゃんと動くようになっています。それはいわゆる「型推論」という機構によって実現されています
が、型を明示した方がプログラムを読みやすくできると判断するなら、いつでもそうしてかまいません。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
関数の定義ができたら、いくつかの例を挙げてそれが正しいものであることをチェックしなければなりません。それを実現するために、Coqには三つの方法が用意されています。一つ目は「<span class="inlinecode"><span class="id" type="keyword">Eval</span> <span class="id" type="var">Simpl</span></span>」コマンドを使って、関数<span class="inlinecode"><span class="id" type="var">next_weekday</span></span>を含んだ式を評価させることです。次のコマンドをよく見て、何をしているかを考えてみてください。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#next_weekday"><span class="id" type="definition">next_weekday</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#friday"><span class="id" type="constructor">friday</span></a>).<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#next_weekday"><span class="id" type="definition">next_weekday</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#next_weekday"><span class="id" type="definition">next_weekday</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#saturday"><span class="id" type="constructor">saturday</span></a>)).<br>

<br>
</div>

<div class="doc">
もし今手元にコンピュータがあるなら、CoqのIDEのうち好きなもの（CoqIDEやProofGeneralなどから）を選んで起動し、実際に上のコマンドを入力し動かしてみるといいでしょう。付録の「<span class="inlinecode"><span class="id" type="var">Basic.v</span></span>」ファイルから上のサンプルを探してCoqに読み込ませ、結果を観察してください。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
「<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>（simplify）」というキーワードは、Coqに対して「我々が与えた式を正確に評価せよ」という命令です。しばらくの間、「<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>」コマンドは我々にとって必要な唯一のコマンドになるでしょう。この後でもう少し使い出のある別のコマンドを覚えるまでの間ですが。 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- ↑IDEで値を確認する方法 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
↑IDEで値を確認する方法
</span><br><br>

<div class="doc">
二番目の方法は、評価の結果として我々が期待しているものをCoqに対してあらかじめ以下のような形で例示しておくというものです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Example</span> <a name="test_next_weekday"><span class="id" type="definition">test_next_weekday</span></a>:<br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#next_weekday"><span class="id" type="definition">next_weekday</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#next_weekday"><span class="id" type="definition">next_weekday</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#saturday"><span class="id" type="constructor">saturday</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#tuesday"><span class="id" type="constructor">tuesday</span></a>.<br>

<br>
</div>

<div class="doc">
この宣言は二つのことを行っています。ひとつは、<span class="inlinecode"><span class="id" type="var">saturday</span></span>の次の次にあたる平日が、<span class="inlinecode"><span class="id" type="var">tuesday</span></span>であるということを確認する必要があるということを示すこと。もう一つは、後で参照しやすいように、その確認事項に<span class="inlinecode"><span class="id" type="var">test_next_weekday</span></span>という名前を与えていることです。
    この確認事項を定義すれば、次のようなコマンドを流すだけで、Coqによって正しさを検証できます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
この文について細かいことは今は置いておきますが（じきに戻ってきます）、本質的には以下のような意味になります「我々が作成した確認事項は簡約後の同値チェックによって証明されました。」 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- ↑証明で確認する方法 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
↑証明で確認する方法
</span><br><br>

<div class="doc">
三番目の方法は、Coqで<span class="inlinecode">定義</span>したものから、他のより一般的な言語（Ocamlや
Scheme、Haskellといった）のプログラムを抽出してしまうことです。この機能は今主流の言語で完全に確認されたプログラムを実現できる道を開
いたという意味でとても興味深いものです。ここではこの件について深入りすることはしませんが、もしより深く知りたいという場合はCoq'Art 
book（Bertot and Casteran著）か、Coqリファレンスマニュアルを参照してください。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab14"></a><h2 class="section">ブール型</h2>

</div>
<div class="code">

<br>
</div>

<div class="doc">
同様にして、<span class="inlinecode"><span class="id" type="var">true</span></span>と<span class="inlinecode"><span class="id" type="var">false</span></span>を値としてとる「<span class="inlinecode"><span class="id" type="var">bool</span>型</span>」を定義することができます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Inductive</span> <a name="bool"><span class="id" type="inductive">bool</span></a> : <span class="id" type="keyword">Type</span> :=<br>
&nbsp;&nbsp;| <a name="true"><span class="id" type="constructor">true</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a><br>
&nbsp;&nbsp;| <a name="false"><span class="id" type="constructor">false</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>.<br>

<br>
</div>

<div class="doc">
このようにして、我々は独自のbool型を一から作りあげることもできるのですが、もちろんCoqには標準ライブラリとしてbool型が多くの有用な関
数、補助定理と一緒に用意されています。（もし興味があるなら、CoqライブラリドキュメントのCoq.Init.Datatypesを参照してくださ
い。）ここでは可能な限り標準ライブラリと正確に同じ機能を、我々独自の名前で定義していくことにしましょう。 
</div>
<div class="code">

<br>

<br>
<span class="id" type="keyword">Definition</span> <a name="negb"><span class="id" type="definition">negb</span></a> (<span class="id" type="var">b</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
<span class="id" type="keyword">Definition</span> <a name="andb"><span class="id" type="definition">andb</span></a> (<span class="id" type="var">b1</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">b2</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> =&gt; <span class="id" type="var">b2</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
<span class="id" type="keyword">Definition</span> <a name="orb"><span class="id" type="definition">orb</span></a> (<span class="id" type="var">b1</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">b2</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> =&gt; <span class="id" type="var">b2</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
後半の二つは、引数を複数持つ関数を定義する方法を示しています。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
次の四つの単体テストは、関数<span class="inlinecode"><span class="id" type="var">orb</span></span>が取り得るすべての引数についての完全な仕様（真理値表）となっています。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Example</span> <a name="test_orb1"><span class="id" type="definition">test_orb1</span></a>:  <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>  <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_orb2"><span class="id" type="definition">test_orb2</span></a>:  <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_orb3"><span class="id" type="definition">test_orb3</span></a>:  <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_orb4"><span class="id" type="definition">test_orb4</span></a>:  <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>  <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
記述方法について: Coqのコード中にコメントを含める場合には、大括弧を使用してコードと区切ります。この慣習は<span class="inlinecode"><span class="id" type="var">coqdoc</span></span>というドキュメント作成ツールでも利用されているのですが、ソース中のコメントをコードから視覚的に分離することができます。CoqソースのHTML版では、コメントはソースとは<span class="inlinecode">別のフォント</span>で表示されます。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
次にCoqでのちょっとトリッキーな定義（<span class="inlinecode"><span class="id" type="var">admit</span></span>）を紹介しましょう。この<span class="inlinecode"><span class="id" type="var">admit</span></span>は、定義や証明にある不完全な部分を「とりあえず今は無いこと」にしてくれるものです。これを次の<span class="inlinecode"><span class="id" type="var">nandb</span></span>での練習問題に使ってみることにしましょう。ここからしばらく、練習問題を解くということは<span class="inlinecode"><span class="id" type="var">admit</span></span>や<span class="inlinecode"><span class="id" type="var">Admitted</span></span>と書かれた部分をちゃんとした定義や証明に書き直す作業になります。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="admit"><span class="id" type="definition">admit</span></a> {<span class="id" type="var">T</span>: <span class="id" type="keyword">Type</span>} : <span class="id" type="var">T</span>. <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- admitは任意の型のデータと考えてよく、Admittedは任意の命題の証明と考えてよい -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
（admitは任意の型のデータと考えてよく、Admittedは任意の命題の証明と考えてよい）
</span><br><br>

<div class="doc">
<a name="lab15"></a><h4 class="section">練習問題: ★ (nandb)</h4>

</div>
<div class="code">
</div>

<div class="doc">
次の定義を完成させ、<span class="inlinecode"><span class="id" type="keyword">Example</span></span>で記述された確認内容がCoqのチェックをすべて通過することを確認しなさい。  
</div>
<div class="code">

<br>
</div>

<div class="doc">
この関数はどちらか、もしくは両方が<span class="inlinecode"><span class="id" type="var">false</span></span>になったときに<span class="inlinecode"><span class="id" type="var">true</span></span>を返すものである。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="nandb"><span class="id" type="definition">nandb</span></a> (<span class="id" type="var">b1</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">b2</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#admit"><span class="id" type="axiom">admit</span></a>.<br>

<br>
</div>

<div class="doc">
下の定義から<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>を取り去り、代わりに"<span class="inlinecode"><span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.</span>"で検証できるようなコードを記述しなさい。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Example</span> <a name="test_nandb1"><span class="id" type="definition">test_nandb1</span></a>:               <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nandb"><span class="id" type="definition">nandb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_nandb2"><span class="id" type="definition">test_nandb2</span></a>:               <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nandb"><span class="id" type="definition">nandb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_nandb3"><span class="id" type="definition">test_nandb3</span></a>:               <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nandb"><span class="id" type="definition">nandb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_nandb4"><span class="id" type="definition">test_nandb4</span></a>:               <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nandb"><span class="id" type="definition">nandb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab16"></a><h4 class="section">練習問題: ★ (andb3)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Definition</span> <a name="andb3"><span class="id" type="definition">andb3</span></a> (<span class="id" type="var">b1</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">b2</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">b3</span>:<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#admit"><span class="id" type="axiom">admit</span></a>.<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_andb31"><span class="id" type="definition">test_andb31</span></a>:                 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb3"><span class="id" type="definition">andb3</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_andb32"><span class="id" type="definition">test_andb32</span></a>:                 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb3"><span class="id" type="definition">andb3</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_andb33"><span class="id" type="definition">test_andb33</span></a>:                 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb3"><span class="id" type="definition">andb3</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_andb34"><span class="id" type="definition">test_andb34</span></a>:                 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb3"><span class="id" type="definition">andb3</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
 </div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab17"></a><h2 class="section">関数の型</h2>

</div>
<div class="code">

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="keyword">Check</span></span>コマンドを使うと、Coqに、指定した式の型を表示させることができます。例えば、（<span class="inlinecode"><span class="id" type="var">negb</span> <span class="id" type="var">true</span></span>）という式の全体の型は<span class="inlinecode"><span class="id" type="var">bool</span></span>である、という具合です。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Check</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>).<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">negb</span></span>のような関数は、それ自身が<span class="inlinecode"><span class="id" type="var">true</span></span>や<span class="inlinecode"><span class="id" type="var">false</span></span>と同じように値であると考えることもできます。そのようにとらえた場合の値の型を「関数型」と呼び、以下のように矢印を使った型として表します。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a>.<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">negb</span></span>の型は<span class="inlinecode"><span class="id" type="var">bool</span><span style="font-family: arial;">→</span><span class="id" type="var">bool</span></span>と書き、「<span class="inlinecode"><span class="id" type="var">bool</span></span>から<span class="inlinecode"><span class="id" type="var">bool</span></span>」と読み、<span class="inlinecode"><span class="id" type="var">bool</span></span>型の引数をとって<span class="inlinecode"><span class="id" type="var">bool</span></span>型の戻り値を返す関数と理解することができます。同様に、<span class="inlinecode"><span class="id" type="var">andb</span></span>の型は<span class="inlinecode"><span class="id" type="var">bool</span> <span style="font-family: arial;">→</span> <span class="id" type="var">bool</span> <span style="font-family: arial;">→</span> <span class="id" type="var">bool</span></span>と書き、「二つの<span class="inlinecode"><span class="id" type="var">bool</span></span>型の値を引数として<span class="inlinecode"><span class="id" type="var">bool</span></span>型の値を作成して戻す」と解釈します。 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- 引数1→引数2→…→戻り値 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
引数1→引数2→…→戻り値
</span><br><br>

<!-- ■ -->
<img src="fig/01-2.png" width="30%" />

<!-- break -->

<div class="doc">

<a name="lab18"></a><h2 class="section">数値</h2>

</div>
<div class="code">

<br>
</div>

<div class="doc">
ちょっと技術的な話：Coqは大規模な開発を支援するためにちょっと大げさにも見えるモジュールシステムを提供しています。このコースではこれらはほとんど必要のないものですが、一つだけ有用なものがあります。プログラムの中のいくつかの要素を<span class="inlinecode"><span class="id" type="keyword">Module</span> <span class="id" type="var">X</span></span>と<span class="inlinecode"><span class="id" type="keyword">End</span> <span class="id" type="var">X</span></span>で囲んでおくと、<span class="inlinecode"><span class="id" type="keyword">End</span> <span class="id" type="var">X</span></span>以降の部分から、囲まれた中の定義を<span class="inlinecode"><span class="id" type="var">X.foo</span></span>という風に呼び出すことができます。このことは、新しく<span class="inlinecode"><span class="id" type="var">foo</span></span>という名前で関数を定義しても問題ないということです。逆に、同じスコープの中では、同じ名前での定義はエラーとなります。という訳で、今回我々はこの機能を使って<span class="inlinecode"><span class="id" type="var">nat</span></span>という型を内部モジュールとして定義します。そうすることで、標準ライブラリの同じ名前の定義を覆い隠してしまわずに済みます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Module</span> <a name="Playground1"><span class="id" type="module">Playground1</span></a>.<br>

<br>
</div>

<!-- ■ -->
<!-- ローカルな定義にできる -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
我々がここまでで定義してきた型は「列挙型」の型定義でした。このような型は、有限の要素をすべて列挙することによって定義されます。型を定義するもう一
つの方法は、「帰納的な記述」を並べることで要素を記述する方法です。例えば、自然数は（全て並べるわけにはいきませんが）以下のような方法で定義できま
す。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Inductive</span> <a name="Playground1.nat"><span class="id" type="inductive">nat</span></a> : <span class="id" type="keyword">Type</span> :=<br>
&nbsp;&nbsp;| <a name="Playground1.O"><span class="id" type="constructor">O</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nat"><span class="id" type="inductive">nat</span></a><br>
&nbsp;&nbsp;| <a name="Playground1.S"><span class="id" type="constructor">S</span></a> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nat"><span class="id" type="inductive">nat</span></a> <span style="font-family: arial;">→</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#nat"><span class="id" type="inductive">nat</span></a>.<br>

<br>
</div>

<div class="doc">
この定義の各句は、以下のように解釈できます。
<ul>
<li> <span class="inlinecode"><span class="id" type="var">O</span></span>は自然数である（<span class="inlinecode">0</span>（ゼロ）ではなく"<span class="inlinecode"><span class="id" type="var">O</span></span>"（オー）であることに注意）

</li>
<li> <span class="inlinecode"><span class="id" type="var">S</span></span>は自然数を引数にとり、別の自然数を生成する「コンストラクタ」である。このことは、<span class="inlinecode"><span class="id" type="var">n</span></span>が自然数なら<span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">n</span></span>も自然数であることを示している。

</li>
</ul>
    この定義にして、もう少し詳しく見ていきましょう。

<br> <br>
    これまでに定義してきた帰納的な型（<span class="inlinecode"><span class="id" type="var">weekday</span></span>、<span class="inlinecode"><span class="id" type="var">nat</span></span>、<span class="inlinecode"><span class="id" type="var">bool</span></span>など）は、実際には式の集合とでも言うべきものです。<span class="inlinecode"><span class="id" type="var">nat</span></span>の定義は、<span class="inlinecode"><span class="id" type="var">nat</span></span>の要素となる式がどのように構築されるかを表しています。
<ul>
<li> 式<span class="inlinecode"><span class="id" type="var">O</span></span>（オー）は、<span class="inlinecode"><span class="id" type="var">nat</span></span>に属する。

</li>
<li> もし<span class="inlinecode"><span class="id" type="var">n</span></span>が<span class="inlinecode"><span class="id" type="var">nat</span></span>に属するならば、<span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">n</span></span>もまた<span class="inlinecode"><span class="id" type="var">nat</span></span>に属する。

</li>
<li> これら二つの方法で表された式のみが<span class="inlinecode"><span class="id" type="var">nat</span></span>に属するものの全てである。
</li>
</ul>

</div>
<div class="code">

<br>
</div>

<div class="doc">
これら三つの条件によって、<span class="inlinecode"><span class="id" type="var">nat</span></span>が帰納的(<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>)な方法で厳格に定義されています。この定義によって、式 <span class="inlinecode"><span class="id" type="var">O</span></span>、式 <span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">O</span></span>、式  <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)</span>、式 <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))</span>...が全て<span class="inlinecode"><span class="id" type="var">nat</span></span>に属する式であることが表されています。また同時に、<span class="inlinecode"><span class="id" type="var">true</span></span>や<span class="inlinecode"><span class="id" type="var">andb</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span></span>、<span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">false</span>)</span>が<span class="inlinecode"><span class="id" type="var">nat</span></span>に属さないことも明確にされています。

<br> <br>
こうして定義された自然数<span class="inlinecode"><span class="id" type="var">nat</span></span>をマターンマッチにかけることで、簡単な関数を書いてみましょう。例えば、一つ前の<span class="inlinecode"><span class="id" type="var">nat</span></span>を返す関数は以下のよう書けます。
 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="Playground1.pred"><span class="id" type="definition">pred</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground1.nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground1.nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground1.O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground1.O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground1.S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt; <span class="id" type="var">n'</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
この２番目の句は「もし<span class="inlinecode"><span class="id" type="var">n</span></span>が何らかの<span class="inlinecode"><span class="id" type="var">n'</span></span>を用いて<span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>と表せるなら、<span class="inlinecode"><span class="id" type="var">n'</span></span>を返す」と読めます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">End</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#"><span class="id" type="module">Playground1</span></a>.<br>

<br>
<span class="id" type="keyword">Definition</span> <a name="minustwo"><span class="id" type="definition">minustwo</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span>) =&gt; <span class="id" type="var">n'</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
自然数というのは非常に一般的な型なので、Coqは自然数を扱ったり表したりするときに若干特別な扱いをします。<span class="inlinecode"><span class="id" type="var">S</span></span>や<span class="inlinecode"><span class="id" type="var">O</span></span>を使った式の代わりに一般的に使われるアラビア数字を使うことができます。実際、Coqは数値を表示する際、デフォルトではアラビア数字を用います。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Check</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>)))).<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#minustwo"><span class="id" type="definition">minustwo</span></a> 4).<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">nat</span></span>のコンストラクタ<span class="inlinecode"><span class="id" type="var">S</span></span>は、<span class="inlinecode"><span class="id" type="var">nat</span> <span style="font-family: arial;">→</span> <span class="id" type="var">nat</span></span>型の関数で<span class="inlinecode"><span class="id" type="var">minustwo</span></span>や<span class="inlinecode"><span class="id" type="var">pred</span></span>も同様です。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a>.<br>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#pred"><span class="id" type="definition">pred</span></a>.<br>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#minustwo"><span class="id" type="definition">minustwo</span></a>.<br>

<br>
</div>

<div class="doc">
これらが表しているのは、いずれの関数も数を引数にとって数を生成できる、ということです。しかしながらこれらの関数には根本的な違いがあります。<span class="inlinecode"><span class="id" type="var">pred</span></span>や<span class="inlinecode"><span class="id" type="var">minustwo</span></span>といった関数には「計算ルール」というものが定義されています。<span class="inlinecode"><span class="id" type="var">pred</span></span>の定義は、<span class="inlinecode"><span class="id" type="var">pred</span> <span class="id" type="var">n</span></span>が<span class="inlinecode"><span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span> | <span class="id" type="var">O</span> =&gt; <span class="id" type="var">O</span> | <span class="id" type="var">S</span> <span class="id" type="var">m'</span> =&gt; <span class="id" type="var">m'</span> <span class="id" type="keyword">end</span></span>のように簡約されることを記述したものですが、一方<span class="inlinecode"><span class="id" type="var">S</span></span>にはそのような定義がありません。しかし両方とも関数には違いなく、引数を元に評価されるということについては同じで、それ以上のものではないのです。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
数値を扱う多くの関数は、単なるパターンマッチだけでは記述できず、再帰的な定義が必要になってきます。例えば、<span class="inlinecode"><span class="id" type="var">n</span></span>が偶数かどうかを調べて返す関数<span class="inlinecode"><span class="id" type="var">evenb</span></span>は、<span class="inlinecode"><span class="id" type="var">n</span>-2</span>が偶数であるかどうかを調べる、という再帰的な定義を必要とします。そういう関数を定義する場合、<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>というキーワードを使用します。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="evenb"><span class="id" type="definition">evenb</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>        =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>      =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span>) =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n'</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- Fixpoint: 再帰的な関数を定義する -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">
Fixpoint: 再帰的な関数を定義する
</span><br><br>

<div class="doc">
Coqがこの定義をチェックする際、<span class="inlinecode"><span class="id" type="var">evenb</span></span>が再帰的に呼ばれるとき、最初の引数が減少しているかに注目します。これは、ここでいう再帰が<span class="inlinecode"><span class="id" type="var">n</span></span>について構造的再帰（もしくは原始的再帰）であること、つまり<span class="inlinecode"><span class="id" type="var">n</span></span>について常により少ない値で再帰呼び出しを行っているか、ということです。これは<span class="inlinecode"><span class="id" type="var">evenb</span></span>が最終的に停止するということを意味しています。Coqは<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>キーワードで定義される関数が常にこの「減少性」を持つことを要求します。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
同じように<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>を使って関数<span class="inlinecode"><span class="id" type="var">oddb</span></span>を定義することもできますが、ここでは次のようにもっとシンプルな用法で簡単に作ってみましょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="oddb"><span class="id" type="definition">oddb</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>   :=   <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n</span>).<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_oddb1"><span class="id" type="definition">test_oddb1</span></a>:    <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#oddb"><span class="id" type="definition">oddb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_oddb2"><span class="id" type="definition">test_oddb2</span></a>:    <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#oddb"><span class="id" type="definition">oddb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>))))<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
当然ながら、引数を複数持つ関数も再帰的に定義することができます。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
ネームスペースを汚さないようにするため、別のモジュールに定義することにしましょう。
</div>
<div class="code">
<span class="id" type="keyword">Module</span> <a name="Playground2"><span class="id" type="module">Playground2</span></a>.<br>

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="Playground2.plus"><span class="id" type="definition">plus</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <span class="id" type="var">m</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#plus"><span class="id" type="definition">plus</span></a> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
3に2を加えた結果は、5になるべきですね。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground2.plus"><span class="id" type="definition">plus</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>))) (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>))).<br>

<br>
</div>

<div class="doc">
Coqがこの計算をどう進めて（簡約して）結論を導くかは以下のように表現できます。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
    <span class="inlinecode"><span class="id" type="var">plus</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))</span>    
</div>
<div class="code">
</div>

<div class="doc">
   ==&gt; <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">plus</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)))</span>    by the second clause of the <span class="inlinecode"><span class="id" type="keyword">match</span></span>
</div>
<div class="code">
</div>

<div class="doc">
   ==&gt; <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">plus</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))))</span>    by the second clause of the <span class="inlinecode"><span class="id" type="keyword">match</span></span>
</div>
<div class="code">
</div>

<div class="doc">
   ==&gt; <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">plus</span> <span class="id" type="var">O</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)))))</span>    by the second clause of the <span class="inlinecode"><span class="id" type="keyword">match</span></span>
</div>
<div class="code">
</div>

<div class="doc">
   ==&gt; <span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))))</span>             by the first clause of the <span class="inlinecode"><span class="id" type="keyword">match</span></span>  
</div>
<div class="code">

<br>
</div>

<div class="doc">
表記を簡便にするため、複数の引数が同じ型を持つときは、型の記述をまとめることができます。 <span class="inlinecode">(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>)</span>は<span class="inlinecode">(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>)</span>と書いたのとまったく同じ意味になります。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="Playground2.mult"><span class="id" type="definition">mult</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#Playground2.plus"><span class="id" type="definition">plus</span></a> <span class="id" type="var">m</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#mult"><span class="id" type="definition">mult</span></a> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
matchに引数を与える際、複数の引数を次のようにカンマで区切って一度に渡すことができます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="Playground2.minus"><span class="id" type="definition">minus</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span>, <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>   , <span class="id" type="var">_</span>    =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">_</span> , <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a>    =&gt; <span class="id" type="var">n</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">m'</span> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#minus"><span class="id" type="definition">minus</span></a> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">minus</span></span>の<span class="inlinecode"><span class="id" type="keyword">match</span></span>の行に現れる( _ )は、ワイルドカードパターンと呼ばれるものです。パターンの中に _ を書くと、それはその部分が何であってもマッチし、その値が使用されないことを意味します。この _ は、このような場合に無意味な名前をつける必要をなくしてくれます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">End</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#"><span class="id" type="module">Playground2</span></a>.<br>

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="exp"><span class="id" type="definition">exp</span></a> (<span class="id" type="var">base</span> <span class="id" type="var">power</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">power</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">p</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#mult"><span class="id" type="definition">mult</span></a> <span class="id" type="var">base</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#exp"><span class="id" type="definition">exp</span></a> <span class="id" type="var">base</span> <span class="id" type="var">p</span>)<br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_mult1"><span class="id" type="definition">test_mult1</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#mult"><span class="id" type="definition">mult</span></a> 3 3<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 9.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab19"></a><h4 class="section">演習問題: ★ (factorial)</h4>

</div>
<div class="code">
</div>

<div class="doc">
再帰を使用した、一般的なfactorical（階乗）の定義を思い出してください :
<pre>    factorial(0)  =  1
    factorial(n)  =  n * factorial(n-1)     (if n&gt;0)
</pre>
    これをCoqでの定義に書き直しなさい。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="factorial"><span class="id" type="definition">factorial</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br>
&nbsp;&nbsp; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#admit"><span class="id" type="axiom">admit</span></a>.<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_factorial1"><span class="id" type="definition">test_factorial1</span></a>:          <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#factorial"><span class="id" type="definition">factorial</span></a> 3<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 6.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_factorial2"><span class="id" type="definition">test_factorial2</span></a>:          <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#factorial"><span class="id" type="definition">factorial</span></a> 5<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#mult"><span class="id" type="definition">mult</span></a> 10 12<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
ここで紹介する"notation"（表記法）という機能を使うことで、加算、減算、乗算のような数値を扱う式をずっと読みやすく、書きやすくすることができます。 
</div>
<div class="code">

<br>
<span class="id" type="var">Notation </span><a name=":nat_scope:x_'+'_x"><span class="id" type="notation">"</span></a>x + y" := (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#plus"><span class="id" type="definition">plus</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">nat_scope</span>.<br>
<span class="id" type="var">Notation </span><a name=":nat_scope:x_'-'_x"><span class="id" type="notation">"</span></a>x - y" := (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#minus"><span class="id" type="definition">minus</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 50, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">nat_scope</span>.<br>
<span class="id" type="var">Notation </span><a name=":nat_scope:x_'*'_x"><span class="id" type="notation">"</span></a>x * y" := (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#mult"><span class="id" type="definition">mult</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 40, <span class="id" type="var">left</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">nat_scope</span>.<br>

<br>
<span class="id" type="keyword">Check</span> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a>0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 1<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 1).<br>

<br>
</div>

<div class="doc">
これらは、これまで我々が定義してきたものを何ら変えるわけではありません。NotationはCoqのパーサに対して<span class="inlinecode"><span class="id" type="var">x</span> + <span class="id" type="var">y</span></span>を<span class="inlinecode"><span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span></span>と解釈させたり、逆に<span class="inlinecode"><span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span></span>を<span class="inlinecode"><span class="id" type="var">x</span> + <span class="id" type="var">y</span></span>と表記させたりするためのものです。

<br> <br>

<!-- ■ -->
<!-- 関数 引数1 引数2 の形より読みやすくできる -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>


各表記法のシンボルは、表記法のスコープ内でのみ有効です。Coqはどのスコープであるかを推測しようとします。<span class="inlinecode"><span class="id" type="var">S</span>(<span class="id" type="var">O</span>*<span class="id" type="var">O</span>)</span>と書かれていた場合は、それを<span class="inlinecode"><span class="id" type="var">nat_scope</span></span>であると推測しますし、ソースにデカルト積（タプル）型<span class="inlinecode"><span class="id" type="var">bool</span>*<span class="id" type="var">bool</span></span>と書かれていたら、<span class="inlinecode"><span class="id" type="var">type_scope</span></span>であると推測します。時には<span class="inlinecode">(<span class="id" type="var">x</span>*<span class="id" type="var">y</span>)%<span class="id" type="var">nat</span></span>といった風に、nat]というような形でCoqからフィードバックされてくることもあります。

<br> <br>
表記のスコープは、多くの場合数値に適用されます。ですので<span class="inlinecode">0%<span class="id" type="var">nat</span></span>という表記を<span class="inlinecode"><span class="id" type="var">O</span></span>（オー）や<span class="inlinecode">0%<span class="id" type="var">Z</span></span>（数値のゼロ）という意味で見ることがあります。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
最初の方で、Coqにはほとんど何も用意されていない、という話をしましたが、本当のところ、数値を比較する関数すら自分で作らなければならないのです！! 
</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">beq_nat</span></span>関数は自然数を比較してbool値を返すものです。入れ子になった<span class="inlinecode"><span class="id" type="keyword">match</span></span>に気をつけて、以下のソースを読んでください。（二つの変数を一度に<span class="inlinecode"><span class="id" type="keyword">match</span></span>させる場合の書き方は、<span class="inlinecode"><span class="id" type="var">minus</span></span>のところですでに登場しています） 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">m'</span> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">m'</span> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
同様に、<span class="inlinecode"><span class="id" type="var">ble_nat</span></span>関数は自然数を比較して小さいか等しい、ということを調べてbool値を生成し返します。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="ble_nat"><span class="id" type="definition">ble_nat</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">m'</span> =&gt; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_ble_nat1"><span class="id" type="definition">test_ble_nat1</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> 2 2<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_ble_nat2"><span class="id" type="definition">test_ble_nat2</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> 2 4<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_ble_nat3"><span class="id" type="definition">test_ble_nat3</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> 4 2<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab20"></a><h4 class="section">練習問題: ★★ (blt_nat)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">blt_nat</span></span>関数は、自然数を比較して小さい、ということを調べてbool値を生成します（ <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" type="var">l</span></span>ess-<span class="inlinecode"><span class="id" type="var">t</span></span>han）。<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>を使用して１から作成するのではなく、すでにこれまで定義した関数を利用して定義しなさい。

<br> <br>
注：<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>タクティックを使ってうまくいかない場合は、代わりに<span class="inlinecode"><span class="id" type="tactic">compute</span></span>を試してください。それはよりうまく作られた<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>と言えるものですが、そもそもシンプルでエレガントな解が書けていれば、<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>で十分に評価できるはずです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Definition</span> <a name="blt_nat"><span class="id" type="definition">blt_nat</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a> :=<br>
&nbsp;&nbsp; <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#admit"><span class="id" type="axiom">admit</span></a>.<br>

<br>
<span class="id" type="keyword">Example</span> <a name="test_blt_nat1"><span class="id" type="definition">test_blt_nat1</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#blt_nat"><span class="id" type="definition">blt_nat</span></a> 2 2<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_blt_nat2"><span class="id" type="definition">test_blt_nat2</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#blt_nat"><span class="id" type="definition">blt_nat</span></a> 2 4<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
<span class="id" type="keyword">Example</span> <a name="test_blt_nat3"><span class="id" type="definition">test_blt_nat3</span></a>:             <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#blt_nat"><span class="id" type="definition">blt_nat</span></a> 4 2<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<img src="fig/01-3.png" width="30%" /><br><br>

<!-- ■ -->
<!-- CoqIDEをインストールし、スクリーンショットを撮って提出 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">レポート1：Teamsの形式手法チームの課題タブを参照してください</span><br><br>
    
<br><span style="background: linear-gradient(transparent 0%, #ffff66 0%); font-size:200%; font-weight: bold; ">01↑↓02</span><br><br>

<!-- ■ -->
<!--
<img src="fig/02-1.png" width="30%" /><br><br>
-->
    
<div class="doc">
<a name="lab21"></a><h1 class="section">簡約を用いた証明</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
ここまでに、いくつかの型や関数を定義してきました。が、ここからは少し目先を変えて、こういった型や関数の特性や振る舞いをどうやって知り、証明してい
くかを考えてみることにしましょう。実際には、すでにこれまでやってきたことでも、その一部に触れています。。例えば、前のセクションの<span class="inlinecode"><span class="id" type="keyword">Example</span></span>は、ある関数にある特定の値を入力した時の振る舞いについて、あらかじめ想定していたものと正確に一致していると主張してくれます。それらの主張が証明しているものは、以下のものと同じです。

<br> <br>
<span class="inlinecode">=</span>の両側の式を定義に基づいて簡約した結果は、一致している。

<br> <br>
このような「簡約を用いた証明」は、関数のさらに興味深い性質をうまく証明することができます。例えば、<span class="inlinecode">0</span>が自然数の加算における左単位元（<span class="inlinecode">0</span>が、左から加えても値が変わらない値であること）であることの証明は、<span class="inlinecode"><span class="id" type="var">n</span></span>が何であっても<span class="inlinecode">0 + <span class="id" type="var">n</span></span>を注意深く縮小(簡約)したものが<span class="inlinecode"><span class="id" type="var">n</span></span>になることを、<span class="inlinecode">+</span>という関数が「最初の引数を引き継いで再帰的に定義されている」ということを考慮した上で示せればいいということです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_O_n"><span class="id" type="lemma">plus_O_n</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>コマンドは暗黙的に＝の両辺を簡約してから等しいかどうかを調べてくれます。そのため、上の証明はもう少し短くすることができます。
</div>
<div class="code">
</div>

<!-- ■ -->
<br>
<!-- reflexivityは=の両辺が等しいことを証明する -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
実際、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>は<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>よりいくぶん多くのことをやってくれるので、覚えておくと後々便利でしょう。例えば、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> は定義された句を展開したり、右辺と置き換えるといったことを試みます。この違いから、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> が向いているのは、「<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> によって全てのゴールが自動的に証明され、<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> が見つけて展開した式をあえて見なくてもよい」という場合で、逆に<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>は、我々自身が新しいゴールを読んで理解すべき時（勝手に定義を展開し解釈して欲しくない時）に向いているということになります。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_O_n'"><span class="id" type="lemma">plus_O_n'</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
この定理と証明の様式は、以前示した例とほとんど同じですが、唯一の違いは、量化子が加えられている（<span class="inlinecode"><span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<span class="id" type="var">nat</span></span>）ことと、<span class="inlinecode"><span class="id" type="keyword">Example</span></span>の代わりに<span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>キーワードが使用されていることです。後者の違いは単なるスタイルの違いで、<span class="inlinecode"><span class="id" type="keyword">Example</span></span>と<span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>（他にも<span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>、<span class="inlinecode"><span class="id" type="keyword">Fact</span></span>、<span class="inlinecode"><span class="id" type="keyword">Remark</span></span>など）はCoqから見るとすべて同じ意味を持ちます。

<br> <br>
<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>や<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>はタクティックの例です。タクティックは、<span class="inlinecode"><span class="id" type="keyword">Proof</span></span>と<span class="inlinecode"><span class="id" type="keyword">Qed</span></span>の
間に記述され、Coqに対して、我々がしようとしている主張の正当性をどのようにチェックすべきかを指示するためのコマンドです。この講義の残りでは、ま
だ出てきていないタクティックのうちのいくつかを紹介していきましょう。さらにその後の講義ではもっと色々出てくるのですが。 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- simplは簡約するだけ -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab22"></a><h4 class="section">練習問題: ★, optional (simpl_plus)</h4>

</div>
<div class="code">
</div>

<div class="doc">
この問い合わせの結果、Coqが返す応答はなにか？ 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes. html#nat"><span class="id" type="inductive">nat</span></a>, <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>).<br>

<br>
</div>

<div class="doc">
また次のものの場合はどうか？ 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>).<br>

<br>
</div>

<div class="doc">
この二つの違いを示せ。  <font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- plusの定義に戻ると違いが分かる -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab23"></a><h1 class="section"><span class="inlinecode"><span class="id" type="tactic">intros</span></span>タクティック</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
単体テストの際には対象の関数に対して特定の引数を渡すわけですが、プログラムの証明を行う上で注意を払うべきポイントは、それが量化子（任意の<span class="inlinecode"><span class="id" type="var">n</span></span>について、など）や仮定（<span class="inlinecode"><span class="id" type="var">m</span>=<span class="id" type="var">n</span></span>と仮定すると）で始まるか、ということです。そのような状況で求められるのは「仮定をたてて証明できる」ことです。例えば「よし、<span class="inlinecode"><span class="id" type="var">n</span></span>を任意の数値としよう」「よし、仮に<span class="inlinecode"><span class="id" type="var">m</span>=<span class="id" type="var">n</span></span>と仮定してみよう」といった具合です。
<br><br>

<!-- ■ -->
<!-- テストは具体的な値に対してのみ ←→ 証明はより一般的 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span>

<br> <br>
<span class="inlinecode"><span class="id" type="tactic">intros</span></span>タクティックは、このようなことを量化子や仮定をゴールから前提条件に移すことで実現してくれます。

<br> <br>
例えば、以下は同じ定理を少し異なるやり方で証明したものです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_O_n''"><span class="id" type="lemma">plus_O_n''</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- intros n： それをnとすると…（nは任意） -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
次の証明をCoq上で逐次実行し、どのように状況が変化してゴールが導かれるのかをよく観察してください。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_1_l"><span class="id" type="lemma">plus_1_l</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 1 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_l"><span class="id" type="lemma">mult_0_l</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
定理の名前についている<span class="inlinecode"><span class="id" type="var">_l</span></span>という接尾辞は、「左の」と読みます。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab24"></a><h1 class="section">書き換え（<span class="inlinecode"><span class="id" type="var">Rewriting</span></span>）による証明</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
少しばかり興味深い定理を見てみましょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_id_example"><span class="id" type="lemma">plus_id_example</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <span style="font-family: arial;">→</span><br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span>.<br>

<br>
</div>

<div class="doc">
この定理は、あらゆる<span class="inlinecode"><span class="id" type="var">n</span></span>や<span class="inlinecode"><span class="id" type="var">m</span></span>について完全に成り立つと言っているわけではなく、<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">m</span></span>が成り立つときに限って成立する、というもので、この矢印は"ならば"と一般的に読みます。

<br> <br>
<span class="inlinecode"><span class="id" type="var">n</span></span>と<span class="inlinecode"><span class="id" type="var">m</span></span>が両方とも任意の数なのですから、これをこれまでの証明でやってきたように簡約することはできません。その代わりに、<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">m</span></span>ならば、イコールの両側の<span class="inlinecode"><span class="id" type="var">n</span></span>や<span class="inlinecode"><span class="id" type="var">m</span></span>を互いに書き換えても等しさは変わらない、というところに注目します。このような書き換えをしてくれるのが<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>タクティックです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. &nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. &nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">H</span>. &nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
証明の1行目は、∀（forall）がついた、つまり「あらゆる<span class="inlinecode"><span class="id" type="var">n</span></span>,<span class="inlinecode"><span class="id" type="var">m</span></span>について」の部分をコンテキストに移しています。2行目は、<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">m</span></span>ならば、という仮定をコンテキストに写し、<span class="inlinecode"><span class="id" type="var">H</span></span>という名前をこれに与えています。3行目は、ゴールになっている式(<span class="inlinecode"><span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span></span>)に仮定<span class="inlinecode"><span class="id" type="var">H</span></span>の左側を右側にするような書き換えを施しています。
<br>

<!-- ■ -->
<!-- intros H： n=mという仮定をHとすると… -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span>

<br> <br>
（<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>の矢印は特に論理に関与していません。単に左側を右側に置き換えているだけです。逆に右側を左側に置き換えたい場合は、<span class="inlinecode"><span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">←</span></span>と書くこともできます。この逆の置き換えも上の証明で試して、Coqの振る舞いがどのように変わるかを観察してください。） 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- rewrite → : =の左を右に置き換える -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab25"></a><h4 class="section">練習問題: ★ (plus_id_exercise)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>を削除し、証明を完成させなさい。
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_id_exercise"><span class="id" type="lemma">plus_id_exercise</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <span style="font-family: arial;">→</span> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">o</span> <span style="font-family: arial;">→</span> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">o</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
Admittedコマンドは、Coqに対して「この証明はあきらめたので、この定理はこれでいいことにしてください」と指示するものです。この機能は、よ
り長い証明をする際に便利です。何か大きな論証をしようとする時、今のところ信用している補足的な命題を示したい時があります。そんな時、<span class="inlinecode"><span class="id" type="var">Admitted</span></span>を使用すると、その命題を一時的に信用できることにして、それを踏み台にしてより大きな論証を進めることができるのです。そしてそれが完成したのち、あらためて保留していた命題の証明を埋めればいいのです。ただし注意して下さい。<span class="inlinecode"><span class="id" type="var">admit</span></span>や<span class="inlinecode"><span class="id" type="var">Admitted</span></span>を使用することは、一時的にドアを開けて、「全て形式的なチェックを受け証明済みの、信用するに足るCoqの世界」から、信用に値しない下界へ足を踏み出していることに他なりません。いつかは戻ってドアを閉めることがお約束です。
</div>
<div class="code">

<br>
</div>

<div class="doc">
仮定の代わりに、前もって証明された定理を使っても<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>タクティックは同じように利用することができます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_plus"><span class="id" type="lemma">mult_0_plus</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a>0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#plus_O_n"><span class="id" type="lemma">plus_O_n</span></a>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab26"></a><h4 class="section">練習問題: ★★, recommended (mult_1_plus)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="mult_1_plus"><span class="id" type="lemma">mult_1_plus</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a>1 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!--
<img src="fig/02-2.png" width="30%" /><br><br>
-->

<div class="doc">
<a name="lab27"></a><h1 class="section">Case分析</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
もちろん、どんな命題でも簡単な計算だけで証明できるという訳ではありません。一般に、未知だったり仮定の（任意のbool、自然数、リストなど）値は、
我々が検証しようとしている関数の先頭に記述され、それが簡約の邪魔をしてくれます。例えば、下のような命題をsimplタクティックだけで証明しようと
すると、すぐに行き詰まってしまうでしょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_1_neq_0_firsttry"><span class="id" type="lemma">plus_1_neq_0_firsttry</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 1) 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<div class="doc">
その原因は、beq_natと+の定義で、共に最初の引数が<span class="inlinecode"><span class="id" type="keyword">match</span></span>に渡されていることです。つまり、<span class="inlinecode">+</span>に渡す最初の引数は<span class="inlinecode"><span class="id" type="var">n</span></span>という未知数な上に、<span class="inlinecode"><span class="id" type="var">beq_nat</span></span>の引数は<span class="inlinecode"><span class="id" type="var">n</span> + 1</span>という複合式になっているため、そのまま簡約できないのです。

<br> <br>
今求められていることは、<span class="inlinecode"><span class="id" type="var">n</span></span>を何らかの条件に分割し、先に進めそうな形にすることができないかを検討することです。もし<span class="inlinecode"><span class="id" type="var">n</span></span>が<span class="inlinecode"><span class="id" type="var">O</span></span>なら、<span class="inlinecode"><span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0</span>の結果を得ることはできます。もちろん結果は<span class="inlinecode"><span class="id" type="var">false</span></span>です。しかしもし<span class="inlinecode"><span class="id" type="var">n</span></span>が何かの<span class="inlinecode"><span class="id" type="var">n'</span></span>を使って<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>と表せると考えても、我々は<span class="inlinecode"><span class="id" type="var">n</span> + 1</span>の値を得ることはできません。ただ、その式が一つの<span class="inlinecode"><span class="id" type="var">S</span></span>で始まる（始まらないものは<span class="inlinecode"><span class="id" type="var">O</span></span>にマッチする）ことに着目すると、<span class="inlinecode"><span class="id" type="var">beq_nat</span></span>の結果を計算して値を求めることができます。その結果結果<span class="inlinecode"><span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0</span>は、やはり<span class="inlinecode"><span class="id" type="var">false</span></span>になるでしょう。

<br> <br>
このことから、求められるタクティックはCoqに<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">O</span></span>の場合と<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>の場合に分けて考えるように求めるようなもので、これを実現するのが<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>タクティックです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_1_neq_0"><span class="id" type="lemma">plus_1_neq_0</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 1) 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>タ
クティックは二つのサブゴールを作ります。その両方を別々に、Coqを使って定理として証明していくことになります。一つのサブゴールからもう一つへ移動
するための特別なコマンドは必要ありません。一つ目のサブゴールが証明されれば、それは消えて自動的にもう一つのサブゴールにフォーカスが移ります。この
証明では、二つに分かれたサブゴールのいずれも<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>を1回使うだけで簡単に証明できます。
<br>

<!-- ■ -->
<!-- destructで場合分けをする -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br>

<br>
destructについている注釈"<span class="inlinecode"><span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>]</span>"は、"イントロパターン"と呼ばれるものです。これはCoqに対して、両方のサブゴールに元<span class="inlinecode"><span class="id" type="var">n</span></span>だった変数をどのような変数名を使って取り入れるかを指示するものです。一般的に<span class="inlinecode">[]</span>の間にあるものは"名前のリスト"で、"<span class="inlinecode">|</span>"によって区切られます。このリストの最初の要素は空ですが、これは<span class="inlinecode"><span class="id" type="var">nat</span></span>の最初のコンストラクタである<span class="inlinecode"><span class="id" type="var">O</span></span>が引数をとらないからです。二つ目のコンストラクタ<span class="inlinecode"><span class="id" type="var">S</span></span>は引数を一つ取りますので、リストの二つ目の要素である<span class="inlinecode"><span class="id" type="var">n'</span></span>を名前に使用します。
<br>

<!-- ■ -->
<!-- as [] で新たに使う変数を指定する -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br>

<br>
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>タクティックは帰納的に定義された型に対して使用できます。例えば、bool値の否定が反射的であること・・・つまり否定の否定が元と同じになることを証明してみましょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="negb_involutive"><span class="id" type="lemma">negb_involutive</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">b</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> <span class="id" type="var">b</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">b</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
ここで使われている<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>には<span class="inlinecode"><span class="id" type="keyword">as</span></span>句がありませんが、ここで展開している<span class="inlinecode"><span class="id" type="var">b</span></span>の型<span class="inlinecode"><span class="id" type="var">bool</span></span>の二つのコンストラクタが両方とも引数をとらないため、名前を指定する必要がないのです。このような場合、"<span class="inlinecode"><span class="id" type="keyword">as</span> [|]</span>"や"<span class="inlinecode"><span class="id" type="keyword">as</span> []</span>"のように書くこともできます。実際のところほとんどの場合<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>の<span class="inlinecode"><span class="id" type="keyword">as</span></span>句は省略可能です。その際はCoqの側で自動的に変数名をつけてくれます。これは確かに便利なのですが、よくない書き方とも言えます。Coqはしばしば名前付けに混乱して望ましくない結果を出す場合があります。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab28"></a><h4 class="section">練習問題: ★ (zero_nbeq_plus_1)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="zero_nbeq_plus_1"><span class="id" type="lemma">zero_nbeq_plus_1</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> 0 (<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 1) <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab29"></a><h1 class="section">Caseへのネーミング</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
caseのサブゴールからサブゴールへ明示的に移動するためのコマンドがないことは、証明の過程と結果を表すスクリプトを読みにくくしていることも事実で
す。さらに大掛かりな証明では、caseの分析も階層化し、Coqを使って証明を進めていくことが苦痛に感じられるかもしれません（あるCaseが五つの
サブゴールを持ち、残りの七つのCaseも他のCaseの内部にあるような状況を想像してみてください･･･）。インデントやコメントを上手に使うと多少
は改善しますが、最もよい解決方法は"<span class="inlinecode"><span class="id" type="var">Case</span></span>"タクティックを定義して使用することです。

<br> <br>
<span class="inlinecode"><span class="id" type="var">Case</span></span>タ
クティックはCoqにビルトインされていませんので、自分で定義する必要があります。それがどのような仕組みで動いているかを理解する必要はありませんの
で、ここでは定義は跳ばして使用例から見ていくことにします。このサンプルは、Coqの機能のうちまだ解説していないstringライブラリとLtacコ
マンドを使用します。これらはカスタムタクティックを定義するときに使うもので、Aaron Bohannon の業績によるものです。 
</div>
<div class="code">

<br>

<code>
From Coq Require Export String.<br>
Open Scope string_scope.
</code>
<br>

<!-- old
<span class="id" type="keyword">Require</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Strings.String.html#"><span class="id" type="library">String</span></a>. <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">string_scope</span>.<br>
-->

<br>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">move_to_top</span> <span class="id" type="var">x</span> :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">reverse</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <span class="id" type="var">H</span> : <span class="id" type="var">_</span> <span style="font-family: arial;">⊢</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="tactic">try</span> <span class="id" type="tactic">move</span> <span class="id" type="var">x</span> <span class="id" type="keyword">after</span> <span class="id" type="var">H</span><br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
<span class="id" type="keyword">Tactic Notation</span> "assert_eq" <span class="id" type="var">ident</span>(<span class="id" type="var">x</span>) <span class="id" type="var">constr</span>(<span class="id" type="var">v</span>) :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H</span> := <span class="id" type="tactic">fresh</span> <span class="id" type="keyword">in</span><br>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">v</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">reflexivity</span>;<br>
&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br>

<br>
<span class="id" type="keyword">Tactic Notation</span> "Case_aux" <span class="id" type="var">ident</span>(<span class="id" type="var">x</span>) <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) :=<br>
&nbsp;&nbsp;<span class="id" type="var">first</span> [<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">set</span> (<span class="id" type="var">x</span> := <span class="id" type="var">name</span>); <span class="id" type="var">move_to_top</span> <span class="id" type="var">x</span><br>
&nbsp;&nbsp;| <span class="id" type="var">assert_eq</span> <span class="id" type="var">x</span> <span class="id" type="var">name</span>; <span class="id" type="var">move_to_top</span> <span class="id" type="var">x</span><br>
&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 1 "because we are working on a different case" ].<br>

<br>
<span class="id" type="keyword">Tactic Notation</span> "Case" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">Case</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSSCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSSSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSSSCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSSSSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSSSSCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSSSSSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSSSSSCase</span> <span class="id" type="var">name</span>.<br>
<span class="id" type="keyword">Tactic Notation</span> "SSSSSSSCase" <span class="id" type="var">constr</span>(<span class="id" type="var">name</span>) := <span class="id" type="var">Case_aux</span> <span class="id" type="var">SSSSSSSCase</span> <span class="id" type="var">name</span>.<br>

<br>
</div>

<div class="doc">
以下は<span class="inlinecode"><span class="id" type="var">Case</span></span>をどのように使うかのサンプルです。証明を順次実行して、コンテキストがどのように変わっていくかを観察しなさい。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="andb_true_elim1"><span class="id" type="lemma">andb_true_elim1</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = true".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = false".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">←</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">Case</span></span>が
行っていることは実はとても簡単です。Caseは、続けて指定されたタグ名を、今証明しようとしているゴールへのコンテキストに文字列として追加している
だけなのです。証明がサブゴールに到達し、証明されると、次のトップレベル（今しがた解決したゴールと兄弟関係にある）ゴールがアクティブになります。す
るとさっきCaseで指定した文字列がすでに証明を終えたcaseとしてコンテキストに現れます。これは健全性のチェックにもなります。もし今の証明が完
了しておらず、コンテキストに残ったまま次の<span class="inlinecode"><span class="id" type="var">Case</span></span>タックティクを実行すると、エラーメッセージが表示されます。

<br> <br>
ネストしたcaseの分析（今<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>で解決しようとしているゴール自体が、他の<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>の産物であるような場合）のために、<span class="inlinecode"><span class="id" type="var">SCase</span></span>("subcase")が用意されています。 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!-- ↑destructの証明を分かりやすくする工夫 -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab30"></a><h4 class="section">練習問題: ★★ (andb_true_elim2)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>を使い、case（もしくはsubcase）を作成して、以下の証明<span class="inlinecode"><span class="id" type="var">andb_true_elim2</span></span>を完成させなさい。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="andb_true_elim2"><span class="id" type="lemma">andb_true_elim2</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">→</span> <span class="id" type="var">c</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
Coq上に証明の経過を記述する際、それをどのようにフォーマットするべきか、ということについてちゃんとしたルールというものはありません。行が分割さ
れ、証明の各段階が階層を持ち、それをインデントで表現するような場合は特にそうです。しかしながら、複数のサブゴールが作成された部分が明示的に<span class="inlinecode"><span class="id" type="var">Case</span></span>タクティックでマークされた場合は、それを行頭から記述することにします。そうしておけば、証明は読みやすくなり、それ以外でどんな方針のレイアウトが選ばれても、あまり問題になりません。

<br> <br>
ここで、１行の長さをどれくらいにしておくべきか、ということにも触れておきましょう。始めたばかりのCoqユーザーは、証明全体を１行に収めようと、複
数のタクティックを同じ行に書き、非常に長い行を書いてしまいがちです。よいスタイルというものは「ほどほど」のところにあります。特にあげるなら、一連
の流れを１行に書くにしても1行80字程度にとどめておくべきでしょう。これ以上長くなると読むのも大変になりますし、印刷や画面表示もうまくいかない場
合が多くなります。多くのエディタがこのような制限をかける機能を持っていますのでそれを使ってもいいでしょう。 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!--
<img src="fig/02-3.png" width="30%" /><br><br>
-->

<!-- ■ -->
<!--
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">レポート2：Teamsの形式手法チームの課題タブを参照してください</span><br><br>
-->

<!-- ■ -->
<br><span style="background: linear-gradient(transparent 0%, #ffff66 0%); font-size:200%; font-weight: bold; ">02↑↓03</span><br><br>

<div class="doc">
<a name="lab31"></a><h1 class="section">帰納法</h1>

</div>

<!-- ■ -->
<!--
<img src="fig/03-1.png" width="30%" /><br><br>
-->

<div class="code">

<br>
</div>

<div class="doc">
我々は以前、<span class="inlinecode">0</span>が加法<span class="inlinecode">+</span>の左単位元（左から加えても値が値が変わらない値）であることを引数を分解し評価することで証明しました。右から加える場合でも同じように証明できるのでしょうか？ 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_0_r_firsttry"><span class="id" type="lemma">plus_0_r_firsttry</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>

<br>
</div>

<div class="doc">
･･･同じぐらい簡単、というわけにはいかないようです。<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>を使ってみても同じです。<span class="inlinecode"><span class="id" type="var">n</span> + 0</span>の<span class="inlinecode"><span class="id" type="var">n</span></span> は任意の未知数であり、<span class="inlinecode">+</span>の定義にある<span class="inlinecode"><span class="id" type="keyword">match</span></span>のせいで簡約できません。<span class="inlinecode"><span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span></span>を使い、caseごとに推論するのも難しそうです。caseごとに考えると<span class="inlinecode"><span class="id" type="var">n</span> = 0</span>のときはうまくいきますが、<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>のほうでは<span class="inlinecode"><span class="id" type="var">n'</span></span>で同じように詰まってしまいます。<span class="inlinecode"><span class="id" type="tactic">destruct</span> <span class="id" type="var">n'</span></span>でさらに一歩踏み込んでみたところで、<span class="inlinecode"><span class="id" type="var">n</span></span>は任意の大きい数のまま動きません。どうやらまだ来たことがないところに迷い込んでしまったようです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<div class="doc">
Caseによる解析は少しだけうまくいきそうに思えますが、やはり行き詰まります。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_0_r_secondtry"><span class="id" type="lemma">plus_0_r_secondtry</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. &nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- destructで場合分けをしても証明が進まない -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
このような命題を証明する場合 － 実際、数値やリストや、その他の帰納的な定義を持つ型にまつわる証明の多くはそうなのですが － もっとずっと強力な推論規則が必要になります。それが「帰納法」です。

<br> <br>
高校で習った帰納法の仕組みを思い出して、自然数を考えてみましょう。もし<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span>が自然数<span class="inlinecode"><span class="id" type="var">n</span></span>に対する命題であるとすると、Pがどんな<span class="inlinecode"><span class="id" type="var">n</span></span>に対しても成り立つことは、以下のような方法で証明できます。
<ul>
<li> <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">O</span>)</span>が成り立つことを示す;

</li>
<li> どんな<span class="inlinecode"><span class="id" type="var">n'</span></span>に対しても、もし<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n'</span>)</span>が成り立つなら<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">S</span> <span class="id" type="var">n'</span>)</span>も成り立つことを示す;

</li>
<li> これによって、<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span>がどんな<span class="inlinecode"><span class="id" type="var">n</span></span>でも成り立つと結論される

</li>
</ul>
Coqでは、それぞれのステップは同じですが順序は逆向きに考えます。まず、ゴールの証明である「任意の<span class="inlinecode"><span class="id" type="var">n</span></span>について<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span>が成り立つ」からはじめ、それを二つの独立したサブゴールに分割します（ここで<span class="inlinecode"><span class="id" type="tactic">induction</span></span>タクティックを使います）。その結果、一つ目のサブゴールは<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">O</span>)</span>、二つ目は<span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n'</span>) <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>(<span class="id" type="var">S</span> <span class="id" type="var">n'</span>)</span>となるはずです。以下は、実際に<span class="inlinecode"><span class="id" type="tactic">induction</span></span>タクティックが先ほど証明しようとしていた定理にどう作用するかを示したものです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_0_r"><span class="id" type="lemma">plus_0_r</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0". <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- IHn'は帰納法の仮定“もし…が成り立つなら”を表している -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>のように、<span class="inlinecode"><span class="id" type="tactic">induction</span></span>タクティックも<span class="inlinecode"><span class="id" type="keyword">as</span>...</span>句を取り、サブゴールに導入する際の変数の名前を指定することができます。最初のブランチでは<span class="inlinecode"><span class="id" type="var">n</span></span>は<span class="inlinecode">0</span>に置き換えられ、ゴールは<span class="inlinecode">0 + 0 = 0</span>となり、簡約できる状態になります。二つ目のブランチでは、<span class="inlinecode"><span class="id" type="var">n</span></span>は<span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>に置き換えられ、<span class="inlinecode"><span class="id" type="var">n'</span> + 0 = <span class="id" type="var">n'</span></span>が前提としてコンテキストに付け加えられます。（この際、仮定に<span class="inlinecode"><span class="id" type="var">IHn'</span></span>という名前がつけられます。これは「Induction Hypothesys for <span class="inlinecode"><span class="id" type="var">n'</span></span>（n'についての帰納法の仮定）」というような意味です。二番目のゴールは<span class="inlinecode">(<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) + 0 = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>となり、<span class="inlinecode"><span class="id" type="var">S</span> (<span class="id" type="var">n'</span> + 0) = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>に簡約されます。ここから、帰納法の仮定<span class="inlinecode"><span class="id" type="var">n'</span> + 0 = <span class="id" type="var">n'</span></span>を使って証明の残りを完成させます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="minus_diag"><span class="id" type="lemma">minus_diag</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>,<br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Peano.html#minus"><span class="id" type="definition">minus</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- ゴールを分ける点はdestructと同様だが、inductionではコンテキストに仮定が加わる -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab32"></a><h4 class="section">練習問題: ★★, recommended (basic_induction)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="mult_0_r"><span class="id" type="lemma">mult_0_r</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<!-- ■
  intros n.
  induction n as [| n'].
  Case "n = 0".
    reflexivity.
  Case "n = S n'".
    simpl.
    rewrite -> IHn'.
    reflexivity.
  Qed.
-->

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_Sm"><span class="id" type="lemma">plus_n_Sm</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<!-- ■
  intros n m.
  induction n as [| n'].
  Case "n = 0".
    reflexivity.
  Case "n = S n'".
    simpl.
    rewrite -> IHn'.
    reflexivity.
  Qed.
-->

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_comm"><span class="id" type="lemma">plus_comm</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Fixpoint</span> <a name="double"><span class="id" type="definition">double</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) :=<br>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a><br>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">n'</span>))<br>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br>

<br>
</div>

<div class="doc">
<a name="lab33"></a><h4 class="section">練習問題: ★★ (double_plus)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="double_plus"><span class="id" type="lemma">double_plus</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>, <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> .<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab34"></a><h4 class="section">練習問題: ★ (destruct_induction)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>と<span class="inlinecode"><span class="id" type="tactic">induction</span></span>の違いを短く説明しなさい。

<br> <br>

<br> <br>

</div>
<div class="code">
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!--
<img src="fig/03-2.png" width="30%" /><br><br>
-->

<div class="doc">
<a name="lab35"></a><h1 class="section">形式的証明と非形式的証明</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
"非形式的な証明はアルゴリズムであり、形式的な証明はコードである" 
</div>
<div class="code">

<br>
</div>

<div class="doc">
数学的に厳格な証明を構成するとはどういうことなのか、という問題は、千年もの間哲学者を悩ませてきました。しかし少々雑な定義でよければ次のように書くこともができます。数学的な命題<span class="inlinecode"><span class="id" type="var">P</span></span>の証明とは、それを読む（あるいは聞く）人をして、<span class="inlinecode"><span class="id" type="var">P</span></span>がtrueであることを納得せしめる文章を書く（語る）ことである、と。このことから、証明はコミュニケーション行為であると言えるでしょう。

<br> <br>
さて、このコミュニケーションの相手は、二種類に分けることができます。一方は、Coqのプログラムのように振る舞うような場合で、このケースでの「信用に値する」というのは、<span class="inlinecode"><span class="id" type="var">P</span></span>が形式的論理のルールに基づく確実な論理から導かれたもので、その証明が、このチェックを行うプログラムをガイドする秘訣になっているようなものです。そんな秘訣が「形式的証明」です。

<br> <br>
一方、読者が人間的な存在で、証明が英語などの自然言語で書かれているようなケースは「非形式的証明」であると言えます。こんなケースでの成功の条件は
「あまりきちんと明示しないこと」です。とにかく、読んでいる人に納得させてしまえる証明こそが「よい証明」なのです。しかしひとつの証明を複数の読者が
見るような場合、ある論点について、ある人は特定の言い回しによって核心に至るかもしれませんが、人によってはそうではないかもしれません。もっと極端な
人は、ただ知ったかぶりをする割りに経験は浅い、単なる「頭でっかち」であるかもしれません。そういった人たちを押しなべて納得させる唯一の方法は、ただ
骨身を惜しまず細かいところまで論じることなのです。逆にある読者はこういったことに精通しているあまり、細かいことにこだわりすぎて全体的な流れを見失
う、ということもあります。多くの人が望んでいることは総論としてどうなのか、ということを知ることで、細かいことを考えていくことは面倒なものです。結
局のところ、非形式的な証明でみんなを納得させる標準的な方法はなさそうです。なぜなら、非形式的な書き方で想定される読者全員を納得させる方法はないか
らです。しかし実際のところ、数学者は複雑な数学的事柄についてたくさんの表記規則のおかげで、証明が正しいか否かを判断するための標準的かつ公正な方法
がもたらされたのです。

<br> <br>
我々はこのコースでCoqを使用しているのですから、それだけできちんと形式化された証明に乗っていると言えます。しかしこのことは、非形式的な表現を無
視していい、ということではありません。形式的証明は多くの場合有効ですが、人と人との間で考えを伝えあう際には必ずしも効率的とは言えないものです。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
例えば、下の例は加法が結合的であることを示すものです。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_assoc'"><span class="id" type="lemma">plus_assoc'</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span>.<br>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>]. <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<div class="doc">
Coqはこのような証明を完璧にこなしてくれますが、上の証明は人間にとってはいささかのみこみにくいと言わざるを得ません。もしあなたがCoqに十分慣
れていて、タクティックを次々と適用しながら証明を進めていき、コンテキストやゴールがどう変化していくかを頭の中だけでイメージしていくことができるよ
うなレベルの人でも、上の証明はかなり複雑で、ほとんど理解不能に思えるかもしれません。それを横目に、数学者はサラサラとこんな風に書くでしょう。 
</div>
<div class="code">
</div>

<div class="doc">
<ul>
<li> 定理：任意の<span class="inlinecode"><span class="id" type="var">n</span></span>,<span class="inlinecode"><span class="id" type="var">m</span></span>,<span class="inlinecode"><span class="id" type="var">p</span></span>について、以下が成り立つ
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">n</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>.
<br> <br>
</span>    証明：<span class="inlinecode"><span class="id" type="var">n</span></span>について帰納法を適用する。

<br> <br>
<ul>
<li> まず<span class="inlinecode"><span class="id" type="var">n</span> = 0</span>と置くと、以下のようになる
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (0 + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>.
<br> <br>
</span>      これは、<span class="inlinecode">+</span>の定義から直接導くことができる。

<br> <br>

</li>
<li> 次に<span class="inlinecode"><span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n'</span></span>と置き、帰納法の仮定を
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n'</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">n'</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>.
<br> <br>
</span>      とすると、以下のような式が立つ。
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = ((<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>.
<br> <br>
</span>      ここで、<span class="inlinecode">+</span>の定義より、以下のように変形できる。
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">S</span> (<span class="id" type="var">n'</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>)) = <span class="id" type="var">S</span> ((<span class="id" type="var">n'</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>),
<br> <br>
</span>      これは、直後の値について帰納法の仮定が成り立つことを示している。 <font size="-2">☐</font> 
</li>
</ul>

</li>
</ul>

</div>
<div class="code">

<br>
</div>

<div class="doc">
どちらの表現も、やっていることは基本的に同じことです。これはもちろん偶然ではなく、Coqの<span class="inlinecode"><span class="id" type="tactic">induction</span></span>タクティックが、数学者が考えるのと同じ目標を、同じサブゴールとして、同じ順番で作成するように作られているだけです。しかしこの二つをよく見ると、重要な違いがあります。形式的証明は、ある部分（<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>を
使っている部分など）ではより明示的ですが、それ以外のところはあまり明示的ではありません。特にあるポイントにおける証明の状態が、Coqの証明では明
示されていません。一方、非形式的証明は、途中で何度も「今どのあたりで、どのようになっているか」を思い出させてくれるような書き方になっています。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
形式的証明も、以下のように書けば構造が分かりすくなります。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_assoc"><span class="id" type="lemma">plus_assoc</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- 形式的な証明が読みにくいのは仕方ないが、できるだけ工夫すべき -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab36"></a><h4 class="section">練習問題: ★★ (plus_comm_informal)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>の証明を、非形式的な証明に書き換えなさい。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
定理：加法は可換である。

<br> <br>
    Proof: <font size="-2">☐</font>

</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab37"></a><h4 class="section">練習問題: ★★, optional (beq_nat_refl_informal)</h4>

</div>
<div class="code">
</div>

<div class="doc">
次の証明を、<span class="inlinecode"><span class="id" type="var">plus_assoc</span></span> の非形式的な証明を参考に書き換えなさい。Coqのタクティックを単に言い換えただけにならないように！

<br> <br>
   定理：true=beq_nat n n forany n.（任意のnについて、nはnと等しいという命題がtrueとなる）

<br> <br>
    Proof: <font size="-2">☐</font>
 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab38"></a><h4 class="section">練習問題: ★, optional (beq_nat_refl)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_refl"><span class="id" type="lemma">beq_nat_refl</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab39"></a><h1 class="section">証明の中で行う証明</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
Coqでは（非形式的な数学と同様に）大きな証明は高い頻度で、後に出てきた証明が前に出ている証明を参照するような定理の列に分割されます。しかし時
折、証明がいくつかの自明で雑他な事実を必要とし、それがまたトップレベルの名前をつけるほどでもなかったりします。こういう場合、状態を単純化し、すで
に使われている定理の右に出現するサブ定理を証明することができれば便利です。<span class="inlinecode"><span class="id" type="tactic">assert</span></span>タクティックはこれを可能にしてくれます。例えば、最初の方でやった証明<span class="inlinecode"><span class="id" type="var">mult_0_plus</span></span>は、<span class="inlinecode"><span class="id" type="var">plus_O_n</span></span>と名付けられた定理の証明から参照されています。<span class="inlinecode"><span class="id" type="tactic">assert</span></span>を使うと<span class="inlinecode"><span class="id" type="var">plus_O_n</span></span>の証明をこんな風に行うことができます。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_plus'"><span class="id" type="lemma">mult_0_plus'</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a>0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span>: 0 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "Proof of assertion". <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">H</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- Hというサブゴールを設定し、証明後にHを利用している -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">assert</span></span>タクティックは、二つのサブゴールを取り込みます。最初のものは<span class="inlinecode"><span class="id" type="var">H</span>:</span>という接頭辞をつけているように、それ自身を主張するもので、Assertion <span class="inlinecode"><span class="id" type="var">H</span></span>と呼びます。
（まず注意が必要なのは、上で使用した<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>や<span class="inlinecode"><span class="id" type="tactic">induction</span></span>に<span class="inlinecode"><span class="id" type="keyword">as</span></span>句をつけることで、<span class="inlinecode"><span class="id" type="tactic">assert</span> (0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H</span></span>というようにassertionに名前をつけられることです。
もう一つ、証明に出てくるassertionに、<span class="inlinecode"><span class="id" type="var">Case</span></span>を使ってマーキングしている事も注目です。その理由は、読みやすさのため、というだけでなく、例えばCoqをインタラクティブに使っているとき、証明を進めている間にコンテキストから<span class="inlinecode">"<span class="id" type="keyword">Proof</span> <span class="id" type="var">of</span> <span class="id" type="var">assertion</span>"</span>という文字列が消える瞬間を観察することで、証明の完了を知ることができます。）二つ目のゴールは、<span class="inlinecode"><span class="id" type="tactic">assert</span></span>を呼び出した場合と、コンテキストに<span class="inlinecode">0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span></span> : <span class="inlinecode"><span class="id" type="var">H</span></span>という仮定が得られることを除けば同じです。このことから、<span class="inlinecode"><span class="id" type="tactic">assert</span></span>は、我々が証明しなければならない事実そのものとなるサブゴールと、その最初のサブゴールの証明がどのような値でも成り立つことを使って証明される事実となる二つ目のサブゴールを作成することが分かります。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
実際<span class="inlinecode"><span class="id" type="tactic">assert</span></span>は多くのシチュエーションで便利に使えるでしょう。例えば、<span class="inlinecode">(<span class="id" type="var">n</span> + <span class="id" type="var">m</span>)
    + (<span class="id" type="var">p</span> + <span class="id" type="var">q</span>) = (<span class="id" type="var">m</span> + <span class="id" type="var">n</span>) + (<span class="id" type="var">p</span> + <span class="id" type="var">q</span>)</span>であることを証明するとしましょう。<span class="inlinecode">=</span>の両側で異なるのは最初のカッコの中の<span class="inlinecode">+</span>の両側の<span class="inlinecode"><span class="id" type="var">n</span></span>と<span class="inlinecode"><span class="id" type="var">m</span></span>が入れ替わっているだけで、このことは加法の交換法則(<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>）があるものを別のものに書き換えることに使用できることを示しています。しかしながら、<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>タクティックは「どこに適用するか」を考える必要がある場合には少々おばかさんです。ここでは<span class="inlinecode">+</span>が3箇所で使われていますが<span class="inlinecode"><span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">plus_comm</span></span>は一番外側（つまり中央）の<span class="inlinecode">+</span>にしか適用されません。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_rearrange_firsttry"><span class="id" type="lemma">plus_rearrange_firsttry</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">q</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">q</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br>
<span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- plus_commが望む所に適用されない -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>を、適用したいポイントに対して使用するには、まず<span class="inlinecode"><span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span></span>で始まるような補助定理（ここでは何とかしようとしている<span class="inlinecode"><span class="id" type="var">m</span></span>と<span class="inlinecode"><span class="id" type="var">n</span></span>を特定するため）を導き、それを望むrewriteに使用します。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_rearrange"><span class="id" type="lemma">plus_rearrange</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">q</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">q</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span>: <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span>).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "Proof of assertion".<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>. <span class="id" type="tactic">reflexivity</span>.<br>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">→</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br>

<br>
</div>

<!-- ■ -->
<!-- assertを使って意図通りにする -->
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">

</span><br><br>

<div class="doc">
<a name="lab40"></a><h4 class="section">練習問題: ★★★★ (mult_comm)</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">assert</span></span>を使用して以下の証明を完成させなさい。ただしinduction（帰納法）を使用しないこと。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_swap"><span class="id" type="lemma">plus_swap</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
</div>

<div class="doc">
では、乗法が可換であることを証明しましょう。おそらく、補助的な定理を定義し、それを使って全体を証明することになると思います。先ほど証明した<span class="inlinecode"><span class="id" type="var">plus_swap</span></span>が便利に使えるでしょう。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_comm"><span class="id" type="lemma">mult_comm</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;<span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab41"></a><h4 class="section">練習問題: ★★, optional (evenb_n__oddb_Sn)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="evenb_n__oddb_Sn"><span class="id" type="lemma">evenb_n__oddb_Sn</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#evenb"><span class="id" type="definition">evenb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>)).<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<!-- ■ -->
<!--
<img src="fig/03-3.png" width="30%" /><br><br>
-->
    
<!-- ■ -->
<!--
<span style="background: linear-gradient(transparent 0%, #ffff66 0%);">レポート3：Teamsの形式手法チームの課題タブを参照してください</span><br><br>
-->

<!-- ■ -->
<br><span style="background: linear-gradient(transparent 0%, #ffff66 0%); font-size:200%; font-weight: bold; ">03↑</span><br><br>

<div class="doc">
<a name="lab42"></a><h1 class="section">さらなる練習問題</h1>

</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab43"></a><h4 class="section">練習問題: ★★★, optional (more_exercises)</h4>

</div>
<div class="code">
</div>

<div class="doc">
紙を何枚か用意して、下に続く定理が(a)簡約と書き換えだけで証明可能か、(b)<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>を使ったcase分割が必要になるか、(c)帰納法が必要となるか、のいずれに属すかを、紙の上だけで考えなさい。予測を紙に書いたら、実際に証明を完成させなさい。証明にはCoqを用いてかまいません。最初に紙を使ったのは「初心忘れるべからず」といった理由です。 
</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="ble_nat_refl"><span class="id" type="lemma">ble_nat_refl</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="zero_nbeq_S"><span class="id" type="lemma">zero_nbeq_S</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> 0 (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="andb_false_r"><span class="id" type="lemma">andb_false_r</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">b</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_ble_compat_l"><span class="id" type="lemma">plus_ble_compat_l</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">→</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> (<span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n</span>) (<span class="id" type="var">p</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="S_nbeq_0"><span class="id" type="lemma">S_nbeq_0</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n</span>) 0 <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#false"><span class="id" type="constructor">false</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_1_l"><span class="id" type="lemma">mult_1_l</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, 1 <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">n</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="all3_spec"><span class="id" type="lemma">all3_spec</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> : <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#bool"><span class="id" type="inductive">bool</span></a>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#orb"><span class="id" type="definition">orb</span></a> (<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> <span class="id" type="var">b</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#negb"><span class="id" type="definition">negb</span></a> <span class="id" type="var">c</span>))<br>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#true"><span class="id" type="constructor">true</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_plus_distr_r"><span class="id" type="lemma">mult_plus_distr_r</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">p</span> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>

<br>
<span class="id" type="keyword">Theorem</span> <a name="mult_assoc"><span class="id" type="lemma">mult_assoc</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">m</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'*'_x"><span class="id" type="notation">*</span></a> <span class="id" type="var">p</span>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab44"></a><h4 class="section">練習問題: ★★, optional (plus_swap')</h4>

</div>
<div class="code">
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">replace</span></span>タクティックは、特定のサブタームを置き換えたいものと置き換えることができます。もう少し正確に言うと、<span class="inlinecode"><span class="id" type="tactic">replace</span> (<span class="id" type="var">t</span>) <span class="id" type="keyword">with</span> (<span class="id" type="var">u</span>)</span>は、ゴールにある<span class="inlinecode"><span class="id" type="var">t</span></span>という式を全て<span class="inlinecode"><span class="id" type="var">u</span></span>にかきかえ、<span class="inlinecode"><span class="id" type="var">t</span> = <span class="id" type="var">u</span></span>というサブゴールを追加します。この機能は、通常の<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>がゴールの思い通りの場所に作用してくれない場合に有効です。

<br> <br>
<span class="inlinecode"><span class="id" type="tactic">replace</span></span>タクティックを使用して<span class="inlinecode"><span class="id" type="var">plus_swap'</span></span>の証明をしなさい。ただし<span class="inlinecode"><span class="id" type="var">plus_swap</span></span>のように<span class="inlinecode"><span class="id" type="tactic">assert</span> (<span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>)</span>を使用しないで証明を完成させなさい。

</div>
<div class="code">

<br>
<span class="id" type="keyword">Theorem</span> <a name="plus_swap'"><span class="id" type="lemma">plus_swap'</span></a> : <span class="id" type="keyword"><span style="font-family: arial;">∀</span></span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br>
&nbsp;&nbsp;<span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.3pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">m</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">n</span> <a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">p</span><a class="idref" href="http://proofcafe.org/sf/Basics_J.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br>
<span class="id" type="keyword">Proof</span>.<br>
 <span class="id" type="var">Admitted</span>.<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab45"></a><h4 class="section">練習問題: ★★★★, recommended (binary)</h4>

</div>
<div class="code">
</div>

<div class="doc">
これまでとは異なる、通常表記の自然数ではなく2進のシステムで、自然数のより効率的な表現を考えなさい。それは自然数をゼロとゼロに1を加える加算器からなるものを定義する代わりに、以下のような2進の形で表すものです。2進数とは、
<ul>
<li> ゼロであるか,

</li>
<li> 2進数を2倍したものか,

</li>
<li> 2進数を2倍したものに1を加えたもの.

</li>
</ul>
    (a) まず、以下のnatの定義に対応するような2進型<span class="inlinecode"><span class="id" type="var">bin</span></span>の帰納的な定義を完成させなさい。
    (ヒント: <span class="inlinecode"><span class="id" type="var">nat</span></span>型の定義を思い出してください。
<br>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span> <span class="id" type="var">nat</span> : <span class="id" type="keyword">Type</span> :=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> : <span class="id" type="var">nat</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">→</span> <span class="id" type="var">nat</span>.
<br> <br>
</span>    nat型の定義<span class="inlinecode"><span class="id" type="var">O</span></span>や<span class="inlinecode"><span class="id" type="var">S</span></span>の意味が何かを語るものではなく、（<span class="inlinecode"><span class="id" type="var">O</span></span>が実際に何であろうが）<span class="inlinecode"><span class="id" type="var">O</span></span>がnatであって、<span class="inlinecode"><span class="id" type="var">n</span></span>がnatなら<span class="inlinecode"><span class="id" type="var">S</span></span>が何であろうと<span class="inlinecode"><span class="id" type="var">S</span> <span class="id" type="var">n</span></span>はnatである、ということを示しているだけです。「<span class="inlinecode"><span class="id" type="var">O</span></span>がゼロで、<span class="inlinecode"><span class="id" type="var">S</span></span>は1を加える」という実装がそれを自然数としてみて実際に関数を書き、実行したり証明したりしてみてはじめて実際に意識されます。ここで定義するbinも同様で、次に書く関数が書かれてはじめて型binに実際の数学的な意味が与えられます。)

<br> <br>
    (b) 先に定義したbin型の値をインクリメントする関数を作成しなさい。また、bin型をnat型に変換する関数も作成しなさい。

<br> <br>
    (c) 
最後にbで作成したインクリメント関数と、2進→自然数関数が可換であることを証明しなさい。これを証明するには、bin値をまずインクリメントしたもの
を自然数に変換したものが、先に自然数変換した後にインクリメントしたものの値と等しいことを証明すればよい。

</div>
<div class="code">

<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<a name="lab46"></a><h4 class="section">練習問題: ★★★★★ (binary_inverse)</h4>

</div>
<div class="code">
</div>

<div class="doc">
この練習問題は前の問題の続きで、2進数に関するものである。前の問題で作成された定義や定理をここで用いてもよい。

<br> <br>
    (a) まず自然数を2進数に変換する関数を書きなさい。そして「任意の自然数からスタートし、それを2進数にコンバートし、それをさらに自然数にコンバートすると、スタート時の自然数に戻ることを証明しなさい。

<br> <br>
    (b) 
あなたはきっと、逆方向についての証明をしたほうがいいのでは、と考えているでしょう。それは、任意の2進数から始まり、それを自然数にコンバートしてか
ら、また2進数にコンバートし直したものが、元の自然数と一致する、という証明です。しかしながら、この結果はtrueにはなりません。！！その原因を説
明しなさい。

<br> <br>
    (c) 2進数を引数として取り、それを一度自然数に変換した後、また2進数に変換したものを返すnormalize関数を作成し、証明しなさい。

</div>
<div class="code">

<br>

<br>
</div>

<div class="doc">
<a name="lab47"></a><h4 class="section">練習問題: ★★, optional (decreasing)</h4>

</div>
<div class="code">
</div>

<div class="doc">
各関数の引数のいくつかが"減少的"でなければならない、という要求仕様は、Coqのデザインにおいて基礎となっているものです。特に、そのことによっ
て、Coq上で作成された関数が、どんな入力を与えられても必ずいつか終了する、ということが保障されています。しかし、Coqの"減少的な解析"が「と
ても洗練されているとまではいえない」ため、時には不自然な書き方で関数を定義しなければならない、ということもあります。

<br> <br>
これを具体的に感じるため、<span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>で定義された、より「微妙な」関数の書き方を考えてみましょう（自然数に関する簡単な関数でかまいません）。それが全ての入力で停止することと、Coqがそれを、この制限のため受け入れてくれないことを確認しなさい。 
</div>
<div class="code">

<br>
</div>

<div class="doc">
<font size="-2">☐</font> 
</div>
<div class="code">

<br>
</div>
</div>

<div id="footer">
<hr><a href="http://proofcafe.org/sf/index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a><hr>
<a href="https://github.com/sfja/sfja">ソフトウェアの基礎 日本語化プロジェクト</a>
</div>

</div>



</body><div></div></html>
